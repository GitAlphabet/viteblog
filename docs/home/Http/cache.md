### 缓存

#### 1、缓存的优点

+ 缓解服务器压力，减少请求次数。
+ 提升性能，打开本地资源肯定会比请求服务器来的快。
+ 减少带宽消耗，当我们使用缓存时，只会产生很小的网络消耗。

#### 2、浏览器缓存位置

+ Service Worker
+ Memory Cache
+ Disk Cache
+ Push Cache

**存储图像和网页等资源主要缓存在disk cache，操作系统缓存文件等资源大部分都会缓存在memory cache中。具体操作浏览器自动分配，看谁的资源利用率不高就分给谁。**

+ **Service Worker**  
是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。

+ **Memory Cache**  
内存中的缓存，主要包含的是当前中页面中已经抓取到的资源，例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快，内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。我们关闭页面，内存中的缓存也就被释放了。

+ **Disk Cache**  
存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。
在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache。
memory cache 要比 disk cache 快的多。
**prefetch cache(预取缓存)**
link标签上带了prefetch，再次加载会出现。
prefetch是预加载的一种方式，被标记为prefetch的资源，将会被浏览器在空闲时间加载。

+ **Push Cache**  
Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。**它只在会话（Session）中存在**，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。

#### 3、强缓存

强缓存是当我们访问URL的时候，不会向服务器发送请求，直接从缓存中读取资源，但是会返回200的状态码。

+ **Pragma**:  
是否使用缓存。可选值为no-cache，告诉浏览器在使用缓存前要发请求到服务器进行验证，不可直接使用缓存

+ **expires**:  
是HTTP1.0控制网页缓存的字段，值为一个时间戳，准确来讲是格林尼治时间，服务器返回该请求结果缓存的到期时间。意思是，发送请求时，如果未超过过期时间，直接使用该缓存，否则重新请求。  
**有个缺点，就是它判断是否过期是用本地时间来判断的，本地时间是可以自己修改的。**

+ **Cache-Control**:  
更细粒度的控制是否可以缓存，可选值如下:
  + **no-store**: 强制禁止所有缓存，禁止保存资源副本，所有资源的请求必需和首次请求一样，从服务器获取资源。
  + **no-cache**: 无论缓存是否过期，都禁止直接使用缓存（即客户端可以保存资源副本），每次请求资源时，需要向源服务器发送验证请求，服务器接收到请求，然后判断资源是否变更，是则返回200和新内容，否则返回304使用缓存副本。
  + **max-age=n**: 表示缓存可用的有效时长，值为一个数字，单位为秒，例如max-age=31536000，表示自请求时间开始，1年内有效
  + **s-maxage=n**: 作用同max-age一样，只是针对的是代理服务器
  + **public**: 表示代理服务器和客户端都可以缓存资源
  + **private**: 表示资源是私有的，只针对单个用户、实体或者窗口进行缓存，不可公用
  + **must-revalidate**: 缓存过期前，可以直接使用缓存副本，但是缓存一旦过期，就必须向源服务器发送验证请求
  + **max-stale=n**: 用法类似max-age，但只在请求头部有效，表示客户端愿意接收一个过期的版本，该资源的过期时间不能超过给定的时间n。

**设置强缓存**  

+ 第一次，请求服务器，然后服务器进行应答，浏览器会根据response Header来判断是否对资源进行缓存，如果响应头中**expires、pragma**或者**cache-control**字段，代表是强缓存，浏览器就会把资源缓存在**memory cache** 或 **disk cache**中。
+ 第二次，浏览器判断请求参数，如果符合强缓存条件就直接返回状态码200，从本地缓存中拿数据。否则把响应参数存在request header请求头中，看是否符合协商缓存，符合则返回状态码304，不符合则服务器会返回全新资源。

::: tip

+ Cache-Control可以设置多个值，以,分隔，例如Cache-Control: no-cache,max-age=3600
+ Pragma为http1.0的产物，已逐步被http1.1的cache-control:no-cache替代，功能一致。http1.1响应首部中出现的Pragma:no-cache只是为了兼容http1.0，实际Cache-Control的优先级更高。
+ **Pragma和Expires同时存在时，Expires不会生效，即Pragma的优先级要高于Expires**
+ Expires的值是一个具体的时间点，这个时间点是相对于服务器的时间，如果客户端的时间和服务器时间不一致，比如手动修改客户机系统时间，那么这个“过期时间”的作用可能会出现偏差，或者说失效
:::

#### 4、协商缓存

协商缓存就是强缓存失效后，浏览器携带缓存标识向服务器发送请求，由服务器根据缓存标识来决定是否使用缓存的过程。

+ **Last-Modified / If-Modified-Since**:  
资源过期后，用于与服务器验证资源时使用，值为资源的最后修改时间
  + Last-Modified: 响应头部中的标识，值为一个具体的GMT（格林威治）时间，表示的是资源最后的修改时间，由服务器返回给客户端，供资源过期时，客户端向服务器发送验证请求时使用
  + If-Modified-Since: 请求头部中的标识，当资源过期后，需要向服务器发送验证请求，如果过期的缓存副本中包含了Last-Modified，那验证请求的头部会带上If-Modified-Since标识，值为缓存副本中Last-Modified的值，服务器获取该值后与资源当前最后修改时间做比较，如果最后修改时间小于或等于请求值，则返回304并更新相关缓存值，如果最后修改时间较新，说明资源被修改过，则返回200和新资源，对应更新缓存

+ **Etag / If-None-Match**:  
资源过期后，用于与服务器验证资源时使用，值是资源的唯一标识
  + Etag: 响应头部中的标识，用于表示资源内容唯一性的标识，该值由服务器生成，生成规则由服务器自行决定，一般是文件大小（size）、修改时间（time）、索引（index）等数据Hash后生成。服务器在响应客户请求时可以带上Etag值，供资源过期时，客户端向服务器发送验证请求时使用
  + If-None-Match: 请求头部中的标识，当资源过期后，需要向服务器发送验证请求，如果过期的缓存副本中包含了Etag，那验证请求的头部会带上 If-None-Match 标识，值为缓存副本中Etag的值，服务器获取该值后与资源当前hash值做比较，如果相同，则返回304并更新相关缓存值，如果不相同，说明资源被修改过，则返回200和新资源，对应更新缓存。

::: tip

+ **ETag比较的是响应内容的特征值，而Last-Modified 比较的是响应内容的修改时间**。这两个是相辅相成的。服务器可以根据自己缓存机制的需要，选择ETag或者是Last-Modified来做缓存判断的依据，甚至可以两个同时参考。
+ **Etag和Last-Modified同时存在时，服务器会优先判断Etag**，如果Etag的值相同会继续判断Last-Modified，最后才决定是返回200还是304状态
:::
