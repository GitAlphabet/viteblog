### js 闭包

闭包是 js 的一个难点也是它的一个特色，是我们必须掌握的 js 高级特性，那么什么是闭包呢？它又有什么用呢？

我们都知道，js 的作用域分两种，全局和局部，基于我们所熟悉的作用域链相关知识，我们知道在 js 作用域环境中访问变量的权利是由内向外的，内部作用域可以获得当前作用域下的变量并且可以获得当前包含当前作用域的外层作用域下的变量，反之则不能，也就是说在外层作用域下无法获取内层作用域下的变量，同样在不同的函数作用域中也是不能相互访问彼此变量的，那么我们想在一个函数内部也有限权访问另一个函数内部的变量该怎么办呢？闭包就是用来解决这一需求的，闭包的本质就是在一个函数内部创建另一个函数。

#### 闭包的特性

- **函数嵌套函数**
- **函数内部可以引用函数外部的参数和变量**
- **参数和变量不会被垃圾回收机制回收**

#### 闭包主要两种形式

- **函数作为返回值**

```js
function outFun() {
  var name = 'outVal'
  return function() {
    console.log(name)
  }
}
var fun = outFun()
fun() // outVal
```

在这段代码中，a()中的返回值是一个匿名函数，这个函数在 outFun()作用域内部，所以它可以获取 outFun()作用域下变量 name 的值，将这个值作为返回值赋给全局作用域下的变量 fun,实现了在全局变量下获取到局部变量中的变量的值

闭包经典案例

```js
function outFun() {
  var num = 1
  return function() {
    var n = 1
    console.log(++n)
    console.log(++num)
  }
}
var fun = outFun()
fun() // 2,2
fun() // 2,3
```

一般情况下，在函数 outFun 执行完后，就应该连同它里面的变量一同被销毁，但是在这个例子中，匿名函数作为 outFun 的返回值被赋值给了 fun，这时相当于 fun=function(){var n = 0 ... }，并且匿名函数内部引用着 fun 里的变量 num，所以变量 num 无法被销毁，而变量 n 是每次被调用时新创建的，所以每次 fn1 执行完后它就把属于自己的变量连同自己一起销毁，于是乎最后就剩下孤零零的 num，于是这里就产生了内存消耗的问题

```js
for (var i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(i)
  }, 1000)
}
// 5 5 5 5 5
```

原来由于 js 是单线程的，所以在执行 for 循环的时候定时器 setTimeout 被安排到任务队列中排队等待执行(涉及到 eventLoop)，而在等待过程中 for 循环就已经在执行，等到 setTimeout 可以执行的时候，for 循环已经结束，i 的值变成了 5，所以打印出来五个 5，那么如何实现预期结果呢？（ps:var 变成 let）

```js
for (var i = 0; i < 5; i++) {
  ;(function(i) {
    setTimeout(function() {
      console.log(i)
    }, 1000)
  })(i)
}
// 0 1 2 3 4
```

引入闭包来保存变量 i，将 setTimeout 放入立即执行函数中，将 for 循环中的循环值 i 作为参数传递

- **闭包作为参数传递**

```js
var num = 15
var fn1 = function(arg) {
  if (arg > num) {
    console.log(arg)
  }
}
void (function(fun) {
  var num = 200
  fun(30)
})(fn1)
// 30
```

函数 fn1 作为参数传入立即执行函数中，在执行到 fun(30)时，30 作为参数传入 fn1 中，这时候 if(arg > num)中的 num 取的并不是立即执行函数中的 num，而是取创建函数的作用域中的 num 这里函数创建的作用域是全局作用域，所以 num 取的是全局作用域中的值 15，即 30>15，打印 30。

#### 优缺点

```markdown
优点:
1、保护函数内的变量安全 ，实现封装，防止变量流入其他环境发生命名冲突
2、在内存中维持一个变量，可以做缓存（但使用多了同时也是一项缺点，消耗内存）
3、匿名自执行函数可以减少内存消耗

缺点:
1、其中一点上面已经有体现了，就是被引用的私有变量不能被销毁，增大了内存消耗，造成内存泄漏，  
解决方法是可以在使用完变量后手动为它赋值为null；
2、其次由于闭包涉及跨域访问，所以会导致性能损失，我们可以通过把跨作用域变量存储在局部变量中，  
然后直接访问局部变量，来减轻对执行速度的影响
```
